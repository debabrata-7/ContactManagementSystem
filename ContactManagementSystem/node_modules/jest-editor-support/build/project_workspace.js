"use strict";

require("core-js/modules/es.object.define-property.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.createProjectWorkspace = void 0;
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.symbol.to-primitive.js");
require("core-js/modules/es.date.to-primitive.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.number.constructor.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
/**
 * a LoginShell holds the shell path and arguments to
 * start an login/interactive shell
 */
/**
 * Represents the project that the extension is running on and it's state
 */
var ProjectWorkspace = exports["default"] = /*#__PURE__*/function () {
  function ProjectWorkspace(rootPath, jestCommandLine, pathToConfig, localJestMajorVersion, outputFileSuffix, collectCoverage, debug, nodeEnv, shell, useDashedArgs) {
    _classCallCheck(this, ProjectWorkspace);
    this.rootPath = rootPath;
    this.jestCommandLine = jestCommandLine;
    this.pathToConfig = pathToConfig;
    this.localJestMajorVersion = localJestMajorVersion;
    this.outputFileSuffix = outputFileSuffix ? outputFileSuffix.replace(/[^a-z0-9]/gi, '_').toLowerCase() : undefined;
    this.collectCoverage = collectCoverage;
    this.debug = debug;
    this.nodeEnv = nodeEnv;
    this.shell = shell;
    this.useDashedArgs = useDashedArgs;
  }
  _createClass(ProjectWorkspace, [{
    key: "pathToJest",
    get:
    /**
     * The path to the root of the project's workspace
     *
     * @type {string}
     */

    /**
     * The command to execute Jest on the command line, this is normally a file path like
     * `node_modules/.bin/jest` but you should not make the assumption that it is always a direct
     * file path, as in a create-react app it would look like `npm test --`.
     *
     * This means when launching a process, you will need to split on the first
     * space, and then move any other args into the args of the process.
     *
     * @type {string}
     */

    /**
     * @deprecated please use `jestCommandLine` instead.
     *
     * @type {string?}
     */
    function get() {
      // eslint-disable-next-line no-console
      console.warn('Use of ProjectWorkspace.pathToJest is deprecated.  Please use jestCommandLine instead.');
      return this.jestCommandLine;
    },
    set: function set(commandLine) {
      // eslint-disable-next-line no-console
      console.warn('Use of ProjectWorkspace.pathToJest is deprecated.  Please use jestCommandLine instead.');
      this.jestCommandLine = commandLine;
    }

    /**
     * Path to a local Jest config file.
     *
     * @type {string}
     */

    /**
     * local Jest major release version, as the runner could run against
     * any version of Jest.
     *
     * @type {number}
     */

    /**
     * Whether test coverage should be (automatically) collected.
     *
     * @type {boolean}
     */

    /**
     * if to output more information for debugging purpose. Default is false.
     *
     * @type {boolean}
     */

    /**
     * suffix string used as part of the output file path, this is to support concurrent Runners.
     *
     * @type {string}
     * @memberof ProjectWorkspace
     */

    /**
     * optional additional node env variables
     */

    /**
     * optional custom shell for node child_process spawn() call. Default is '/bin/sh' on Unix, and process.env.ComSpec on Windows.
     * see https://nodejs.org/api/child_process.html#child_process_child_process_spawn_command_args_options
     *
     * If a string is passed in, a non-login/non-interactive shell will be used to spawn the child_process
     * If a terminal-shell is passed, a login/interactive shell will be used to spawn the child_process. This is not as efficient as
     * the non-login/non-interactive shell, but might be needed if parent environment is not guarenteed to be properly initialized
     * (see https://github.com/jest-community/vscode-jest/issues/741)
     */

    /**
     * Wether dashed args should be used for the jest command line. Default is false.
     */
  }]);
  return ProjectWorkspace;
}();
/**
 * A factory to create a ProjectWorkspace instance from a ProjectWorkspaceConfig object.
 */
var createProjectWorkspace = exports.createProjectWorkspace = function createProjectWorkspace(config) {
  // Note for pathToConfig we are forcing the TS compiler to accept undefined for ProjectWorkspace.pathToConfig.
  // This property should be allowed to be optional, since Jest will work fine if no config file is provided.  It
  // will just use defaults.
  return new ProjectWorkspace(config.rootPath, config.jestCommandLine, config.pathToConfig, config.localJestMajorVersion, config.outputFileSuffix, config.collectCoverage, config.debug, config.nodeEnv, config.shell, config.useDashedArgs);
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJQcm9qZWN0V29ya3NwYWNlIiwiZXhwb3J0cyIsInJvb3RQYXRoIiwiamVzdENvbW1hbmRMaW5lIiwicGF0aFRvQ29uZmlnIiwibG9jYWxKZXN0TWFqb3JWZXJzaW9uIiwib3V0cHV0RmlsZVN1ZmZpeCIsImNvbGxlY3RDb3ZlcmFnZSIsImRlYnVnIiwibm9kZUVudiIsInNoZWxsIiwidXNlRGFzaGVkQXJncyIsIl9jbGFzc0NhbGxDaGVjayIsInJlcGxhY2UiLCJ0b0xvd2VyQ2FzZSIsInVuZGVmaW5lZCIsIl9jcmVhdGVDbGFzcyIsImtleSIsImdldCIsImNvbnNvbGUiLCJ3YXJuIiwic2V0IiwiY29tbWFuZExpbmUiLCJjcmVhdGVQcm9qZWN0V29ya3NwYWNlIiwiY29uZmlnIl0sInNvdXJjZXMiOlsiLi4vc3JjL3Byb2plY3Rfd29ya3NwYWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKlxuICogYSBMb2dpblNoZWxsIGhvbGRzIHRoZSBzaGVsbCBwYXRoIGFuZCBhcmd1bWVudHMgdG9cbiAqIHN0YXJ0IGFuIGxvZ2luL2ludGVyYWN0aXZlIHNoZWxsXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTG9naW5TaGVsbCB7XG4gIC8qKiBzaGVsbCBleGVjdXRhYmxlIHBhdGggKi9cbiAgcGF0aDogc3RyaW5nO1xuICAvKiogc2hlbGwgYXJndW1lbnRzICovXG4gIGFyZ3M6IHN0cmluZ1tdO1xufVxuZXhwb3J0IGludGVyZmFjZSBQcm9qZWN0V29ya3NwYWNlQ29uZmlnIHtcbiAgamVzdENvbW1hbmRMaW5lOiBzdHJpbmc7XG4gIHBhdGhUb0NvbmZpZz86IHN0cmluZztcbiAgcm9vdFBhdGg6IHN0cmluZztcbiAgbG9jYWxKZXN0TWFqb3JWZXJzaW9uOiBudW1iZXI7XG4gIG91dHB1dEZpbGVTdWZmaXg/OiBzdHJpbmc7XG4gIGNvbGxlY3RDb3ZlcmFnZT86IGJvb2xlYW47XG4gIGRlYnVnPzogYm9vbGVhbjtcbiAgbm9kZUVudj86IHtba2V5OiBzdHJpbmddOiBzdHJpbmcgfCB1bmRlZmluZWR9O1xuICBzaGVsbD86IHN0cmluZyB8IExvZ2luU2hlbGw7XG4gIHVzZURhc2hlZEFyZ3M/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHByb2plY3QgdGhhdCB0aGUgZXh0ZW5zaW9uIGlzIHJ1bm5pbmcgb24gYW5kIGl0J3Mgc3RhdGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvamVjdFdvcmtzcGFjZSB7XG4gIC8qKlxuICAgKiBUaGUgcGF0aCB0byB0aGUgcm9vdCBvZiB0aGUgcHJvamVjdCdzIHdvcmtzcGFjZVxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgcm9vdFBhdGg6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGNvbW1hbmQgdG8gZXhlY3V0ZSBKZXN0IG9uIHRoZSBjb21tYW5kIGxpbmUsIHRoaXMgaXMgbm9ybWFsbHkgYSBmaWxlIHBhdGggbGlrZVxuICAgKiBgbm9kZV9tb2R1bGVzLy5iaW4vamVzdGAgYnV0IHlvdSBzaG91bGQgbm90IG1ha2UgdGhlIGFzc3VtcHRpb24gdGhhdCBpdCBpcyBhbHdheXMgYSBkaXJlY3RcbiAgICogZmlsZSBwYXRoLCBhcyBpbiBhIGNyZWF0ZS1yZWFjdCBhcHAgaXQgd291bGQgbG9vayBsaWtlIGBucG0gdGVzdCAtLWAuXG4gICAqXG4gICAqIFRoaXMgbWVhbnMgd2hlbiBsYXVuY2hpbmcgYSBwcm9jZXNzLCB5b3Ugd2lsbCBuZWVkIHRvIHNwbGl0IG9uIHRoZSBmaXJzdFxuICAgKiBzcGFjZSwgYW5kIHRoZW4gbW92ZSBhbnkgb3RoZXIgYXJncyBpbnRvIHRoZSBhcmdzIG9mIHRoZSBwcm9jZXNzLlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgamVzdENvbW1hbmRMaW5lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHBsZWFzZSB1c2UgYGplc3RDb21tYW5kTGluZWAgaW5zdGVhZC5cbiAgICpcbiAgICogQHR5cGUge3N0cmluZz99XG4gICAqL1xuICBnZXQgcGF0aFRvSmVzdCgpOiBzdHJpbmcge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS53YXJuKCdVc2Ugb2YgUHJvamVjdFdvcmtzcGFjZS5wYXRoVG9KZXN0IGlzIGRlcHJlY2F0ZWQuICBQbGVhc2UgdXNlIGplc3RDb21tYW5kTGluZSBpbnN0ZWFkLicpO1xuICAgIHJldHVybiB0aGlzLmplc3RDb21tYW5kTGluZTtcbiAgfVxuXG4gIHNldCBwYXRoVG9KZXN0KGNvbW1hbmRMaW5lOiBzdHJpbmcpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUud2FybignVXNlIG9mIFByb2plY3RXb3Jrc3BhY2UucGF0aFRvSmVzdCBpcyBkZXByZWNhdGVkLiAgUGxlYXNlIHVzZSBqZXN0Q29tbWFuZExpbmUgaW5zdGVhZC4nKTtcbiAgICB0aGlzLmplc3RDb21tYW5kTGluZSA9IGNvbW1hbmRMaW5lO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdGggdG8gYSBsb2NhbCBKZXN0IGNvbmZpZyBmaWxlLlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgcGF0aFRvQ29uZmlnOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIGxvY2FsIEplc3QgbWFqb3IgcmVsZWFzZSB2ZXJzaW9uLCBhcyB0aGUgcnVubmVyIGNvdWxkIHJ1biBhZ2FpbnN0XG4gICAqIGFueSB2ZXJzaW9uIG9mIEplc3QuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBsb2NhbEplc3RNYWpvclZlcnNpb246IG51bWJlcjtcblxuICAvKipcbiAgICogV2hldGhlciB0ZXN0IGNvdmVyYWdlIHNob3VsZCBiZSAoYXV0b21hdGljYWxseSkgY29sbGVjdGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGNvbGxlY3RDb3ZlcmFnZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIGlmIHRvIG91dHB1dCBtb3JlIGluZm9ybWF0aW9uIGZvciBkZWJ1Z2dpbmcgcHVycG9zZS4gRGVmYXVsdCBpcyBmYWxzZS5cbiAgICpcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBkZWJ1Zz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIHN1ZmZpeCBzdHJpbmcgdXNlZCBhcyBwYXJ0IG9mIHRoZSBvdXRwdXQgZmlsZSBwYXRoLCB0aGlzIGlzIHRvIHN1cHBvcnQgY29uY3VycmVudCBSdW5uZXJzLlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAbWVtYmVyb2YgUHJvamVjdFdvcmtzcGFjZVxuICAgKi9cbiAgb3V0cHV0RmlsZVN1ZmZpeD86IHN0cmluZztcblxuICAvKipcbiAgICogb3B0aW9uYWwgYWRkaXRpb25hbCBub2RlIGVudiB2YXJpYWJsZXNcbiAgICovXG4gIG5vZGVFbnY/OiB7W2tleTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkfTtcblxuICAvKipcbiAgICogb3B0aW9uYWwgY3VzdG9tIHNoZWxsIGZvciBub2RlIGNoaWxkX3Byb2Nlc3Mgc3Bhd24oKSBjYWxsLiBEZWZhdWx0IGlzICcvYmluL3NoJyBvbiBVbml4LCBhbmQgcHJvY2Vzcy5lbnYuQ29tU3BlYyBvbiBXaW5kb3dzLlxuICAgKiBzZWUgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9jaGlsZF9wcm9jZXNzLmh0bWwjY2hpbGRfcHJvY2Vzc19jaGlsZF9wcm9jZXNzX3NwYXduX2NvbW1hbmRfYXJnc19vcHRpb25zXG4gICAqXG4gICAqIElmIGEgc3RyaW5nIGlzIHBhc3NlZCBpbiwgYSBub24tbG9naW4vbm9uLWludGVyYWN0aXZlIHNoZWxsIHdpbGwgYmUgdXNlZCB0byBzcGF3biB0aGUgY2hpbGRfcHJvY2Vzc1xuICAgKiBJZiBhIHRlcm1pbmFsLXNoZWxsIGlzIHBhc3NlZCwgYSBsb2dpbi9pbnRlcmFjdGl2ZSBzaGVsbCB3aWxsIGJlIHVzZWQgdG8gc3Bhd24gdGhlIGNoaWxkX3Byb2Nlc3MuIFRoaXMgaXMgbm90IGFzIGVmZmljaWVudCBhc1xuICAgKiB0aGUgbm9uLWxvZ2luL25vbi1pbnRlcmFjdGl2ZSBzaGVsbCwgYnV0IG1pZ2h0IGJlIG5lZWRlZCBpZiBwYXJlbnQgZW52aXJvbm1lbnQgaXMgbm90IGd1YXJlbnRlZWQgdG8gYmUgcHJvcGVybHkgaW5pdGlhbGl6ZWRcbiAgICogKHNlZSBodHRwczovL2dpdGh1Yi5jb20vamVzdC1jb21tdW5pdHkvdnNjb2RlLWplc3QvaXNzdWVzLzc0MSlcbiAgICovXG4gIHNoZWxsPzogc3RyaW5nIHwgTG9naW5TaGVsbDtcblxuICAvKipcbiAgICogV2V0aGVyIGRhc2hlZCBhcmdzIHNob3VsZCBiZSB1c2VkIGZvciB0aGUgamVzdCBjb21tYW5kIGxpbmUuIERlZmF1bHQgaXMgZmFsc2UuXG4gICAqL1xuICB1c2VEYXNoZWRBcmdzPzogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICByb290UGF0aDogc3RyaW5nLFxuICAgIGplc3RDb21tYW5kTGluZTogc3RyaW5nLFxuICAgIHBhdGhUb0NvbmZpZzogc3RyaW5nLFxuICAgIGxvY2FsSmVzdE1ham9yVmVyc2lvbjogbnVtYmVyLFxuICAgIG91dHB1dEZpbGVTdWZmaXg/OiBzdHJpbmcsXG4gICAgY29sbGVjdENvdmVyYWdlPzogYm9vbGVhbixcbiAgICBkZWJ1Zz86IGJvb2xlYW4sXG4gICAgbm9kZUVudj86IHtba2V5OiBzdHJpbmddOiBzdHJpbmcgfCB1bmRlZmluZWR9LFxuICAgIHNoZWxsPzogc3RyaW5nIHwgTG9naW5TaGVsbCxcbiAgICB1c2VEYXNoZWRBcmdzPzogYm9vbGVhblxuICApIHtcbiAgICB0aGlzLnJvb3RQYXRoID0gcm9vdFBhdGg7XG4gICAgdGhpcy5qZXN0Q29tbWFuZExpbmUgPSBqZXN0Q29tbWFuZExpbmU7XG4gICAgdGhpcy5wYXRoVG9Db25maWcgPSBwYXRoVG9Db25maWc7XG4gICAgdGhpcy5sb2NhbEplc3RNYWpvclZlcnNpb24gPSBsb2NhbEplc3RNYWpvclZlcnNpb247XG4gICAgdGhpcy5vdXRwdXRGaWxlU3VmZml4ID0gb3V0cHV0RmlsZVN1ZmZpeCA/IG91dHB1dEZpbGVTdWZmaXgucmVwbGFjZSgvW15hLXowLTldL2dpLCAnXycpLnRvTG93ZXJDYXNlKCkgOiB1bmRlZmluZWQ7XG4gICAgdGhpcy5jb2xsZWN0Q292ZXJhZ2UgPSBjb2xsZWN0Q292ZXJhZ2U7XG4gICAgdGhpcy5kZWJ1ZyA9IGRlYnVnO1xuICAgIHRoaXMubm9kZUVudiA9IG5vZGVFbnY7XG4gICAgdGhpcy5zaGVsbCA9IHNoZWxsO1xuICAgIHRoaXMudXNlRGFzaGVkQXJncyA9IHVzZURhc2hlZEFyZ3M7XG4gIH1cbn1cblxuLyoqXG4gKiBBIGZhY3RvcnkgdG8gY3JlYXRlIGEgUHJvamVjdFdvcmtzcGFjZSBpbnN0YW5jZSBmcm9tIGEgUHJvamVjdFdvcmtzcGFjZUNvbmZpZyBvYmplY3QuXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVQcm9qZWN0V29ya3NwYWNlID0gKGNvbmZpZzogUHJvamVjdFdvcmtzcGFjZUNvbmZpZyk6IFByb2plY3RXb3Jrc3BhY2UgPT4ge1xuICAvLyBOb3RlIGZvciBwYXRoVG9Db25maWcgd2UgYXJlIGZvcmNpbmcgdGhlIFRTIGNvbXBpbGVyIHRvIGFjY2VwdCB1bmRlZmluZWQgZm9yIFByb2plY3RXb3Jrc3BhY2UucGF0aFRvQ29uZmlnLlxuICAvLyBUaGlzIHByb3BlcnR5IHNob3VsZCBiZSBhbGxvd2VkIHRvIGJlIG9wdGlvbmFsLCBzaW5jZSBKZXN0IHdpbGwgd29yayBmaW5lIGlmIG5vIGNvbmZpZyBmaWxlIGlzIHByb3ZpZGVkLiAgSXRcbiAgLy8gd2lsbCBqdXN0IHVzZSBkZWZhdWx0cy5cbiAgcmV0dXJuIG5ldyBQcm9qZWN0V29ya3NwYWNlKFxuICAgIGNvbmZpZy5yb290UGF0aCxcbiAgICBjb25maWcuamVzdENvbW1hbmRMaW5lLFxuICAgIGNvbmZpZy5wYXRoVG9Db25maWcgYXMgdW5rbm93biBhcyBzdHJpbmcsXG4gICAgY29uZmlnLmxvY2FsSmVzdE1ham9yVmVyc2lvbixcbiAgICBjb25maWcub3V0cHV0RmlsZVN1ZmZpeCxcbiAgICBjb25maWcuY29sbGVjdENvdmVyYWdlLFxuICAgIGNvbmZpZy5kZWJ1ZyxcbiAgICBjb25maWcubm9kZUVudixcbiAgICBjb25maWcuc2hlbGwsXG4gICAgY29uZmlnLnVzZURhc2hlZEFyZ3NcbiAgKTtcbn07XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBb0JBO0FBQ0E7QUFDQTtBQUZBLElBR3FCQSxnQkFBZ0IsR0FBQUMsT0FBQTtFQStGbkMsU0FBQUQsaUJBQ0VFLFFBQWdCLEVBQ2hCQyxlQUF1QixFQUN2QkMsWUFBb0IsRUFDcEJDLHFCQUE2QixFQUM3QkMsZ0JBQXlCLEVBQ3pCQyxlQUF5QixFQUN6QkMsS0FBZSxFQUNmQyxPQUE2QyxFQUM3Q0MsS0FBMkIsRUFDM0JDLGFBQXVCLEVBQ3ZCO0lBQUFDLGVBQUEsT0FBQVosZ0JBQUE7SUFDQSxJQUFJLENBQUNFLFFBQVEsR0FBR0EsUUFBUTtJQUN4QixJQUFJLENBQUNDLGVBQWUsR0FBR0EsZUFBZTtJQUN0QyxJQUFJLENBQUNDLFlBQVksR0FBR0EsWUFBWTtJQUNoQyxJQUFJLENBQUNDLHFCQUFxQixHQUFHQSxxQkFBcUI7SUFDbEQsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBR0EsZ0JBQWdCLEdBQUdBLGdCQUFnQixDQUFDTyxPQUFPLENBQUMsYUFBYSxFQUFFLEdBQUcsQ0FBQyxDQUFDQyxXQUFXLENBQUMsQ0FBQyxHQUFHQyxTQUFTO0lBQ2pILElBQUksQ0FBQ1IsZUFBZSxHQUFHQSxlQUFlO0lBQ3RDLElBQUksQ0FBQ0MsS0FBSyxHQUFHQSxLQUFLO0lBQ2xCLElBQUksQ0FBQ0MsT0FBTyxHQUFHQSxPQUFPO0lBQ3RCLElBQUksQ0FBQ0MsS0FBSyxHQUFHQSxLQUFLO0lBQ2xCLElBQUksQ0FBQ0MsYUFBYSxHQUFHQSxhQUFhO0VBQ3BDO0VBQUNLLFlBQUEsQ0FBQWhCLGdCQUFBO0lBQUFpQixHQUFBO0lBQUFDLEdBQUE7SUFwSEQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7SUFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7SUFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0lBQ0UsU0FBQUEsSUFBQSxFQUF5QjtNQUN2QjtNQUNBQyxPQUFPLENBQUNDLElBQUksQ0FBQyx3RkFBd0YsQ0FBQztNQUN0RyxPQUFPLElBQUksQ0FBQ2pCLGVBQWU7SUFDN0IsQ0FBQztJQUFBa0IsR0FBQSxFQUVELFNBQUFBLElBQWVDLFdBQW1CLEVBQUU7TUFDbEM7TUFDQUgsT0FBTyxDQUFDQyxJQUFJLENBQUMsd0ZBQXdGLENBQUM7TUFDdEcsSUFBSSxDQUFDakIsZUFBZSxHQUFHbUIsV0FBVztJQUNwQzs7SUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztJQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7SUFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztJQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0lBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztJQUdFO0FBQ0Y7QUFDQTs7SUFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0lBR0U7QUFDRjtBQUNBO0VBRkU7RUFBQSxPQUFBdEIsZ0JBQUE7QUFBQTtBQThCRjtBQUNBO0FBQ0E7QUFDTyxJQUFNdUIsc0JBQXNCLEdBQUF0QixPQUFBLENBQUFzQixzQkFBQSxHQUFHLFNBQXpCQSxzQkFBc0JBLENBQUlDLE1BQThCLEVBQXVCO0VBQzFGO0VBQ0E7RUFDQTtFQUNBLE9BQU8sSUFBSXhCLGdCQUFnQixDQUN6QndCLE1BQU0sQ0FBQ3RCLFFBQVEsRUFDZnNCLE1BQU0sQ0FBQ3JCLGVBQWUsRUFDdEJxQixNQUFNLENBQUNwQixZQUFZLEVBQ25Cb0IsTUFBTSxDQUFDbkIscUJBQXFCLEVBQzVCbUIsTUFBTSxDQUFDbEIsZ0JBQWdCLEVBQ3ZCa0IsTUFBTSxDQUFDakIsZUFBZSxFQUN0QmlCLE1BQU0sQ0FBQ2hCLEtBQUssRUFDWmdCLE1BQU0sQ0FBQ2YsT0FBTyxFQUNkZSxNQUFNLENBQUNkLEtBQUssRUFDWmMsTUFBTSxDQUFDYixhQUNULENBQUM7QUFDSCxDQUFDIn0=