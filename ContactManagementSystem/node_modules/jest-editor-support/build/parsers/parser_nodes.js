"use strict";

require("core-js/modules/es.symbol.to-primitive.js");
require("core-js/modules/es.date.to-primitive.js");
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.number.constructor.js");
require("core-js/modules/es.object.define-property.js");
require("core-js/modules/es.object.set-prototype-of.js");
require("core-js/modules/es.function.bind.js");
require("core-js/modules/es.object.get-prototype-of.js");
require("core-js/modules/es.reflect.construct.js");
require("core-js/modules/es.object.create.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ParsedRange = exports.ParsedNodeTypes = exports.ParsedNode = exports.ParseResult = exports.NamedBlock = exports.ItBlock = exports.Expect = exports.DescribeBlock = void 0;
require("core-js/modules/es.array.for-each.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/web.dom-collections.for-each.js");
require("core-js/modules/es.function.name.js");
require("core-js/modules/es.array.some.js");
require("core-js/modules/es.array.concat.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
/* eslint-disable no-use-before-define */
/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
/**
 * range and location here are 1-based position.
 */
var ParsedRange = exports.ParsedRange = /*#__PURE__*/_createClass(function ParsedRange(startLine, startCol, endLine, endCol) {
  _classCallCheck(this, ParsedRange);
  this.start = {
    column: startCol,
    line: startLine
  };
  this.end = {
    column: endCol,
    line: endLine
  };
}); // export type ParsedNodeType = 'expect' | 'describe' | 'it' | 'ROOT';
var ParsedNodeTypes = exports.ParsedNodeTypes = {
  describe: 'describe',
  expect: 'expect',
  it: 'it',
  root: 'root'
};
var ParsedNode = exports.ParsedNode = /*#__PURE__*/function () {
  function ParsedNode(type, file) {
    _classCallCheck(this, ParsedNode);
    this.type = type;
    this.file = file;
  }
  _createClass(ParsedNode, [{
    key: "addChild",
    value: function addChild(type) {
      var child;
      switch (type) {
        case ParsedNodeTypes.describe:
          child = new DescribeBlock(this.file);
          break;
        case ParsedNodeTypes.it:
          child = new ItBlock(this.file);
          break;
        case ParsedNodeTypes.expect:
          child = new Expect(this.file);
          break;
        default:
          throw TypeError("unexpected child node type: ".concat(type));
      }
      if (!this.children) {
        this.children = [child];
      } else {
        this.children.push(child);
      }
      return child;
    }
  }, {
    key: "filter",
    value: function filter(f) {
      var filterSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var filtered = [];
      var _filter = function _filter(node, _filterSelf) {
        if (_filterSelf && f(node)) {
          filtered.push(node);
        }
        if (node.children) {
          node.children.forEach(function (c) {
            return _filter(c, true);
          });
        }
      };
      _filter(this, filterSelf);
      return filtered;
    }
  }]);
  return ParsedNode;
}();
var Expect = exports.Expect = /*#__PURE__*/function (_ParsedNode) {
  _inherits(Expect, _ParsedNode);
  var _super = _createSuper(Expect);
  function Expect(file) {
    _classCallCheck(this, Expect);
    return _super.call(this, ParsedNodeTypes.expect, file);
  }
  return _createClass(Expect);
}(ParsedNode);
var NamedBlock = exports.NamedBlock = /*#__PURE__*/function (_ParsedNode2) {
  _inherits(NamedBlock, _ParsedNode2);
  var _super2 = _createSuper(NamedBlock);
  /**
   * type of the name, it's the babel Node["type"], such as "Literal", "TemplateLiteral" etc
   *
   * TODO babel parser currently returns "Literal" for the it/describe name argument, which is not part of its "type" definition, therefore declare a string type for now until it is fixed in babel.
   * */

  function NamedBlock(type, file, name) {
    var _this;
    _classCallCheck(this, NamedBlock);
    _this = _super2.call(this, type, file);
    if (name) {
      _this.name = name;
    }
    return _this;
  }
  return _createClass(NamedBlock);
}(ParsedNode);
var ItBlock = exports.ItBlock = /*#__PURE__*/function (_NamedBlock) {
  _inherits(ItBlock, _NamedBlock);
  var _super3 = _createSuper(ItBlock);
  function ItBlock(file, name) {
    _classCallCheck(this, ItBlock);
    return _super3.call(this, ParsedNodeTypes.it, file, name);
  }
  return _createClass(ItBlock);
}(NamedBlock);
var DescribeBlock = exports.DescribeBlock = /*#__PURE__*/function (_NamedBlock2) {
  _inherits(DescribeBlock, _NamedBlock2);
  var _super4 = _createSuper(DescribeBlock);
  function DescribeBlock(file, name) {
    _classCallCheck(this, DescribeBlock);
    return _super4.call(this, ParsedNodeTypes.describe, file, name);
  }
  return _createClass(DescribeBlock);
}(NamedBlock); // export type NodeClass = Node | Expect | ItBlock | DescribeBlock;
var ParseResult = exports.ParseResult = /*#__PURE__*/function () {
  function ParseResult(file) {
    _classCallCheck(this, ParseResult);
    this.file = file;
    this.root = new ParsedNode(ParsedNodeTypes.root, file);
    this.describeBlocks = [];
    this.expects = [];
    this.itBlocks = [];
  }
  _createClass(ParseResult, [{
    key: "addNode",
    value: function addNode(node) {
      var dedup = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (node instanceof DescribeBlock) {
        this.describeBlocks.push(node);
      } else if (node instanceof ItBlock) {
        this.itBlocks.push(node);
      } else if (node instanceof Expect) {
        if (dedup && this.expects.some(function (e) {
          return e.start.line === node.start.line && e.start.column === node.start.column;
        })) {
          // found dup, return
          return;
        }
        this.expects.push(node);
      } else {
        throw new TypeError("unexpected node class '".concat(_typeof(node), "': ").concat(JSON.stringify(node)));
      }
    }
  }]);
  return ParseResult;
}();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJQYXJzZWRSYW5nZSIsImV4cG9ydHMiLCJfY3JlYXRlQ2xhc3MiLCJzdGFydExpbmUiLCJzdGFydENvbCIsImVuZExpbmUiLCJlbmRDb2wiLCJfY2xhc3NDYWxsQ2hlY2siLCJzdGFydCIsImNvbHVtbiIsImxpbmUiLCJlbmQiLCJQYXJzZWROb2RlVHlwZXMiLCJkZXNjcmliZSIsImV4cGVjdCIsIml0Iiwicm9vdCIsIlBhcnNlZE5vZGUiLCJ0eXBlIiwiZmlsZSIsImtleSIsInZhbHVlIiwiYWRkQ2hpbGQiLCJjaGlsZCIsIkRlc2NyaWJlQmxvY2siLCJJdEJsb2NrIiwiRXhwZWN0IiwiVHlwZUVycm9yIiwiY29uY2F0IiwiY2hpbGRyZW4iLCJwdXNoIiwiZmlsdGVyIiwiZiIsImZpbHRlclNlbGYiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJmaWx0ZXJlZCIsIl9maWx0ZXIiLCJub2RlIiwiX2ZpbHRlclNlbGYiLCJmb3JFYWNoIiwiYyIsIl9QYXJzZWROb2RlIiwiX2luaGVyaXRzIiwiX3N1cGVyIiwiX2NyZWF0ZVN1cGVyIiwiY2FsbCIsIk5hbWVkQmxvY2siLCJfUGFyc2VkTm9kZTIiLCJfc3VwZXIyIiwibmFtZSIsIl90aGlzIiwiX05hbWVkQmxvY2siLCJfc3VwZXIzIiwiX05hbWVkQmxvY2syIiwiX3N1cGVyNCIsIlBhcnNlUmVzdWx0IiwiZGVzY3JpYmVCbG9ja3MiLCJleHBlY3RzIiwiaXRCbG9ja3MiLCJhZGROb2RlIiwiZGVkdXAiLCJzb21lIiwiZSIsIl90eXBlb2YiLCJKU09OIiwic3RyaW5naWZ5Il0sInNvdXJjZXMiOlsiLi4vLi4vc3JjL3BhcnNlcnMvcGFyc2VyX25vZGVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLXVzZS1iZWZvcmUtZGVmaW5lICovXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IHR5cGUge0xvY2F0aW9ufSBmcm9tICcuLi90eXBlcyc7XG5cbi8qKlxuICogcmFuZ2UgYW5kIGxvY2F0aW9uIGhlcmUgYXJlIDEtYmFzZWQgcG9zaXRpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXJzZWRSYW5nZSB7XG4gIHN0YXJ0OiBMb2NhdGlvbjtcblxuICBlbmQ6IExvY2F0aW9uO1xuXG4gIGNvbnN0cnVjdG9yKHN0YXJ0TGluZTogbnVtYmVyLCBzdGFydENvbDogbnVtYmVyLCBlbmRMaW5lOiBudW1iZXIsIGVuZENvbDogbnVtYmVyKSB7XG4gICAgdGhpcy5zdGFydCA9IHtjb2x1bW46IHN0YXJ0Q29sLCBsaW5lOiBzdGFydExpbmV9O1xuICAgIHRoaXMuZW5kID0ge2NvbHVtbjogZW5kQ29sLCBsaW5lOiBlbmRMaW5lfTtcbiAgfVxufVxuXG4vLyBleHBvcnQgdHlwZSBQYXJzZWROb2RlVHlwZSA9ICdleHBlY3QnIHwgJ2Rlc2NyaWJlJyB8ICdpdCcgfCAnUk9PVCc7XG5cbmV4cG9ydCBjb25zdCBQYXJzZWROb2RlVHlwZXMgPSB7XG4gIGRlc2NyaWJlOiAnZGVzY3JpYmUnLFxuICBleHBlY3Q6ICdleHBlY3QnLFxuICBpdDogJ2l0JyxcbiAgcm9vdDogJ3Jvb3QnLFxufTtcblxuZXhwb3J0IHR5cGUgUGFyc2VkTm9kZVR5cGUgPSAkS2V5czx0eXBlb2YgUGFyc2VkTm9kZVR5cGVzPjtcblxuZXhwb3J0IGNsYXNzIFBhcnNlZE5vZGUge1xuICB0eXBlOiBQYXJzZWROb2RlVHlwZTtcblxuICBzdGFydDogTG9jYXRpb247XG5cbiAgZW5kOiBMb2NhdGlvbjtcblxuICBmaWxlOiBzdHJpbmc7XG5cbiAgY2hpbGRyZW46ID9BcnJheTxQYXJzZWROb2RlPjtcblxuICBjb25zdHJ1Y3Rvcih0eXBlOiBQYXJzZWROb2RlVHlwZSwgZmlsZTogc3RyaW5nKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmZpbGUgPSBmaWxlO1xuICB9XG5cbiAgYWRkQ2hpbGQodHlwZTogUGFyc2VkTm9kZVR5cGUpOiBQYXJzZWROb2RlIHtcbiAgICBsZXQgY2hpbGQ6IFBhcnNlZE5vZGU7XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgUGFyc2VkTm9kZVR5cGVzLmRlc2NyaWJlOlxuICAgICAgICBjaGlsZCA9IG5ldyBEZXNjcmliZUJsb2NrKHRoaXMuZmlsZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQYXJzZWROb2RlVHlwZXMuaXQ6XG4gICAgICAgIGNoaWxkID0gbmV3IEl0QmxvY2sodGhpcy5maWxlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBhcnNlZE5vZGVUeXBlcy5leHBlY3Q6XG4gICAgICAgIGNoaWxkID0gbmV3IEV4cGVjdCh0aGlzLmZpbGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IFR5cGVFcnJvcihgdW5leHBlY3RlZCBjaGlsZCBub2RlIHR5cGU6ICR7dHlwZX1gKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNoaWxkcmVuKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuID0gW2NoaWxkXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG5cbiAgZmlsdGVyKGY6IChub2RlOiBQYXJzZWROb2RlKSA9PiBib29sZWFuLCBmaWx0ZXJTZWxmOiBib29sZWFuID0gZmFsc2UpOiBBcnJheTxQYXJzZWROb2RlPiB7XG4gICAgY29uc3QgZmlsdGVyZWQ6IEFycmF5PFBhcnNlZE5vZGU+ID0gW107XG5cbiAgICBjb25zdCBfZmlsdGVyID0gKG5vZGU6IFBhcnNlZE5vZGUsIF9maWx0ZXJTZWxmOiBib29sZWFuKSA9PiB7XG4gICAgICBpZiAoX2ZpbHRlclNlbGYgJiYgZihub2RlKSkge1xuICAgICAgICBmaWx0ZXJlZC5wdXNoKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goKGMpID0+IF9maWx0ZXIoYywgdHJ1ZSkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfZmlsdGVyKHRoaXMsIGZpbHRlclNlbGYpO1xuICAgIHJldHVybiBmaWx0ZXJlZDtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRXhwZWN0IGV4dGVuZHMgUGFyc2VkTm9kZSB7XG4gIGNvbnN0cnVjdG9yKGZpbGU6IHN0cmluZykge1xuICAgIHN1cGVyKFBhcnNlZE5vZGVUeXBlcy5leHBlY3QsIGZpbGUpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBOYW1lZEJsb2NrIGV4dGVuZHMgUGFyc2VkTm9kZSB7XG4gIG5hbWU6IHN0cmluZztcblxuICBuYW1lUmFuZ2U6IFBhcnNlZFJhbmdlO1xuXG4gIGxhc3RQcm9wZXJ0eTogP3N0cmluZztcblxuICAvKipcbiAgICogdHlwZSBvZiB0aGUgbmFtZSwgaXQncyB0aGUgYmFiZWwgTm9kZVtcInR5cGVcIl0sIHN1Y2ggYXMgXCJMaXRlcmFsXCIsIFwiVGVtcGxhdGVMaXRlcmFsXCIgZXRjXG4gICAqXG4gICAqIFRPRE8gYmFiZWwgcGFyc2VyIGN1cnJlbnRseSByZXR1cm5zIFwiTGl0ZXJhbFwiIGZvciB0aGUgaXQvZGVzY3JpYmUgbmFtZSBhcmd1bWVudCwgd2hpY2ggaXMgbm90IHBhcnQgb2YgaXRzIFwidHlwZVwiIGRlZmluaXRpb24sIHRoZXJlZm9yZSBkZWNsYXJlIGEgc3RyaW5nIHR5cGUgZm9yIG5vdyB1bnRpbCBpdCBpcyBmaXhlZCBpbiBiYWJlbC5cbiAgICogKi9cbiAgbmFtZVR5cGU6ID9zdHJpbmc7XG5cbiAgY29uc3RydWN0b3IodHlwZTogUGFyc2VkTm9kZVR5cGUsIGZpbGU6IHN0cmluZywgbmFtZT86IHN0cmluZykge1xuICAgIHN1cGVyKHR5cGUsIGZpbGUpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgSXRCbG9jayBleHRlbmRzIE5hbWVkQmxvY2sge1xuICBjb25zdHJ1Y3RvcihmaWxlOiBzdHJpbmcsIG5hbWU/OiBzdHJpbmcpIHtcbiAgICBzdXBlcihQYXJzZWROb2RlVHlwZXMuaXQsIGZpbGUsIG5hbWUpO1xuICB9XG59XG5leHBvcnQgY2xhc3MgRGVzY3JpYmVCbG9jayBleHRlbmRzIE5hbWVkQmxvY2sge1xuICBjb25zdHJ1Y3RvcihmaWxlOiBzdHJpbmcsIG5hbWU/OiBzdHJpbmcpIHtcbiAgICBzdXBlcihQYXJzZWROb2RlVHlwZXMuZGVzY3JpYmUsIGZpbGUsIG5hbWUpO1xuICB9XG59XG5cbi8vIGV4cG9ydCB0eXBlIE5vZGVDbGFzcyA9IE5vZGUgfCBFeHBlY3QgfCBJdEJsb2NrIHwgRGVzY3JpYmVCbG9jaztcblxuZXhwb3J0IGNsYXNzIFBhcnNlUmVzdWx0IHtcbiAgZGVzY3JpYmVCbG9ja3M6IEFycmF5PERlc2NyaWJlQmxvY2s+O1xuXG4gIGV4cGVjdHM6IEFycmF5PEV4cGVjdD47XG5cbiAgaXRCbG9ja3M6IEFycmF5PEl0QmxvY2s+O1xuXG4gIHJvb3Q6IFBhcnNlZE5vZGU7XG5cbiAgZmlsZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKGZpbGU6IHN0cmluZykge1xuICAgIHRoaXMuZmlsZSA9IGZpbGU7XG4gICAgdGhpcy5yb290ID0gbmV3IFBhcnNlZE5vZGUoUGFyc2VkTm9kZVR5cGVzLnJvb3QsIGZpbGUpO1xuXG4gICAgdGhpcy5kZXNjcmliZUJsb2NrcyA9IFtdO1xuICAgIHRoaXMuZXhwZWN0cyA9IFtdO1xuICAgIHRoaXMuaXRCbG9ja3MgPSBbXTtcbiAgfVxuXG4gIGFkZE5vZGUobm9kZTogUGFyc2VkTm9kZSwgZGVkdXA6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xuICAgIGlmIChub2RlIGluc3RhbmNlb2YgRGVzY3JpYmVCbG9jaykge1xuICAgICAgdGhpcy5kZXNjcmliZUJsb2Nrcy5wdXNoKG5vZGUpO1xuICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEl0QmxvY2spIHtcbiAgICAgIHRoaXMuaXRCbG9ja3MucHVzaChub2RlKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBFeHBlY3QpIHtcbiAgICAgIGlmIChkZWR1cCAmJiB0aGlzLmV4cGVjdHMuc29tZSgoZSkgPT4gZS5zdGFydC5saW5lID09PSBub2RlLnN0YXJ0LmxpbmUgJiYgZS5zdGFydC5jb2x1bW4gPT09IG5vZGUuc3RhcnQuY29sdW1uKSkge1xuICAgICAgICAvLyBmb3VuZCBkdXAsIHJldHVyblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZXhwZWN0cy5wdXNoKG5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB1bmV4cGVjdGVkIG5vZGUgY2xhc3MgJyR7dHlwZW9mIG5vZGV9JzogJHtKU09OLnN0cmluZ2lmeShub2RlKX1gKTtcbiAgICB9XG4gIH1cbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUZBLElBR2FBLFdBQVcsR0FBQUMsT0FBQSxDQUFBRCxXQUFBLGdCQUFBRSxZQUFBLENBS3RCLFNBQUFGLFlBQVlHLFNBQWlCLEVBQUVDLFFBQWdCLEVBQUVDLE9BQWUsRUFBRUMsTUFBYyxFQUFFO0VBQUFDLGVBQUEsT0FBQVAsV0FBQTtFQUNoRixJQUFJLENBQUNRLEtBQUssR0FBRztJQUFDQyxNQUFNLEVBQUVMLFFBQVE7SUFBRU0sSUFBSSxF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